"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[5649],{146:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>h});var o=t(4848),r=t(8453);const s={title:"Contexts",sidebar_label:"Contexts",description:"Using contexts to pass deeply nested data"},c=void 0,i={id:"concepts/contexts",title:"Contexts",description:"Using contexts to pass deeply nested data",source:"@site/docs/concepts/contexts.mdx",sourceDirName:"concepts",slug:"/concepts/contexts",permalink:"/docs/next/concepts/contexts",draft:!1,unlisted:!1,editUrl:"https://google.com/docs/concepts/contexts.mdx",tags:[],version:"current",frontMatter:{title:"Contexts",sidebar_label:"Contexts",description:"Using contexts to pass deeply nested data"},sidebar:"docs",previous:{title:"Agents",permalink:"/docs/next/concepts/agents"},next:{title:"Router",permalink:"/docs/next/concepts/router"}},a={},h=[{value:"The problem with props: &quot;Prop Drilling&quot;",id:"the-problem-with-props-prop-drilling",level:2},{value:"Using Contexts",id:"using-contexts",level:2},{value:"Step 1: Providing the context",id:"step-1-providing-the-context",level:3},{value:"Step 2: Consuming context",id:"step-2-consuming-context",level:3},{value:"Function components",id:"function-components",level:4},{value:"Struct components",id:"struct-components",level:4},{value:"Use cases",id:"use-cases",level:2},{value:"Considerations to make before using contexts",id:"considerations-to-make-before-using-contexts",level:3},{value:"Mutating the context value of a child",id:"mutating-the-context-value-of-a-child",level:2},{value:"Further reading",id:"further-reading",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Usually, data is passed from a parent component to a child component via props.\r\nBut passing props can become verbose and annoying if you have to pass them through many components in the middle,\r\nor if many components in your app need the same information. Context solves this problem by allowing a\r\nparent component to make data available to ",(0,o.jsx)(n.em,{children:"any"})," component in the tree below it, no matter how deep,\r\nwithout having to pass it down with props."]}),"\n",(0,o.jsx)(n.h2,{id:"the-problem-with-props-prop-drilling",children:'The problem with props: "Prop Drilling"'}),"\n",(0,o.jsxs)(n.p,{children:["Passing ",(0,o.jsx)(n.a,{href:"/docs/next/concepts/function-components/properties",children:"props"}),' is a great way to pass data directly from a parent to a child.\r\nThey become cumbersome to pass down through deeply nested component trees or when multiple components share the same data.\r\nA common solution to data sharing is lifting the data to a common ancestor and making the children take it as props.\r\nHowever, this can lead to cases where the prop has to go through multiple components to reach the component that needs it.\r\nThis situation is called "Prop Drilling".']}),"\n",(0,o.jsx)(n.p,{children:"Consider the following example which passes down the theme using props:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use yew::{html, Component, Context, Html, Properties, function_component};\r\n\r\n#[derive(Clone, PartialEq)]\r\npub struct Theme {\r\n    foreground: String,\r\n    background: String,\r\n}\r\n\r\n#[derive(PartialEq, Properties)]\r\npub struct NavbarProps {\r\n    theme: Theme,\r\n}\r\n\r\n#[function_component]\r\nfn Navbar(props: &NavbarProps) -> Html {\r\n    html! {\r\n        <div>\r\n            <Title theme={props.theme.clone()}>\r\n                { "App title" }\r\n            </Title>\r\n            <NavButton theme={props.theme.clone()}>\r\n                { "Somewhere" }\r\n            </NavButton>\r\n        </div>\r\n    }\r\n}\r\n\r\n#[derive(PartialEq, Properties)]\r\npub struct ThemeProps {\r\n    theme: Theme,\r\n    children: Html,\r\n}\r\n\r\n#[function_component]\r\nfn Title(_props: &ThemeProps) -> Html {\r\n    html! {\r\n        // impl\r\n    }\r\n}\r\n\r\n#[function_component]\r\nfn NavButton(_props: &ThemeProps) -> Html {\r\n    html! {\r\n        // impl\r\n    }\r\n}\r\n\r\n/// App root\r\n#[function_component]\r\nfn App() -> Html {\r\n    let theme = Theme {\r\n        foreground: "yellow".to_owned(),\r\n        background: "pink".to_owned(),\r\n    };\r\n\r\n    html! {\r\n        <Navbar {theme} />\r\n    }\r\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:['We "drill" the theme prop through ',(0,o.jsx)(n.code,{children:"Navbar"})," so that it can reach ",(0,o.jsx)(n.code,{children:"Title"})," and ",(0,o.jsx)(n.code,{children:"NavButton"}),".\r\nIt would be nice if ",(0,o.jsx)(n.code,{children:"Title"})," and ",(0,o.jsx)(n.code,{children:"NavButton"}),", the components that need access to the theme, can just access the theme\r\nwithout having to pass it to them as a prop. Contexts solve this problem by allowing a parent to pass data, theme in this case,\r\nto its children."]}),"\n",(0,o.jsx)(n.h2,{id:"using-contexts",children:"Using Contexts"}),"\n",(0,o.jsx)(n.h3,{id:"step-1-providing-the-context",children:"Step 1: Providing the context"}),"\n",(0,o.jsxs)(n.p,{children:["A context provider is required to consume the context. ",(0,o.jsx)(n.code,{children:"ContextProvider<T>"}),", where ",(0,o.jsx)(n.code,{children:"T"})," is the context struct used as the provider.\r\n",(0,o.jsx)(n.code,{children:"T"})," must implement ",(0,o.jsx)(n.code,{children:"Clone"})," and ",(0,o.jsx)(n.code,{children:"PartialEq"}),". ",(0,o.jsx)(n.code,{children:"ContextProvider"})," is the component whose children will have the context available to them.\r\nThe children are re-rendered when the context changes. A struct is used to define what data is to be passed. The ",(0,o.jsx)(n.code,{children:"ContextProvider"})," can be used as:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use yew::prelude::*;\r\n\r\n\r\n/// App theme\r\n#[derive(Clone, Debug, PartialEq)]\r\nstruct Theme {\r\n    foreground: String,\r\n    background: String,\r\n}\r\n\r\n/// Main component\r\n#[function_component]\r\npub fn App() -> Html {\r\n    let ctx = use_state(|| Theme {\r\n        foreground: "#000000".to_owned(),\r\n        background: "#eeeeee".to_owned(),\r\n    });\r\n\r\n    html! {\r\n        // `ctx` is type `Rc<UseStateHandle<Theme>>` while we need `Theme`\r\n        // so we deref it.\r\n        // It derefs to `&Theme`, hence the clone\r\n        <ContextProvider<Theme> context={(*ctx).clone()}>\r\n            // Every child here and their children will have access to this context.\r\n            <Toolbar />\r\n        </ContextProvider<Theme>>\r\n    }\r\n}\r\n\r\n/// The toolbar.\r\n/// This component has access to the context\r\n#[function_component]\r\npub fn Toolbar() -> Html {\r\n    html! {\r\n        <div>\r\n            <ThemedButton />\r\n        </div>\r\n    }\r\n}\r\n\r\n/// Button placed in `Toolbar`.\r\n/// As this component is a child of `ThemeContextProvider` in the component tree, it also has access\r\n/// to the context.\r\n#[function_component]\r\npub fn ThemedButton() -> Html {\r\n    let theme = use_context::<Theme>().expect("no ctx found");\r\n\r\n    html! {\r\n        <button style={format!("background: {}; color: {};", theme.background, theme.foreground)}>\r\n            { "Click me!" }\r\n        </button>\r\n    }\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"step-2-consuming-context",children:"Step 2: Consuming context"}),"\n",(0,o.jsx)(n.h4,{id:"function-components",children:"Function components"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"use_context"})," hook is used to consume contexts in function components.\r\nSee ",(0,o.jsx)(n.a,{href:"https://yew-rs-api.web.app/next/yew/functional/fn.use_context.html",children:"docs for use_context"})," to learn more."]}),"\n",(0,o.jsx)(n.h4,{id:"struct-components",children:"Struct components"}),"\n",(0,o.jsx)(n.p,{children:"We have 2 options to consume contexts in struct components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/next/advanced-topics/struct-components/hoc",children:"Higher Order Components"}),": A higher-order function component will consume the context and pass the data to the struct component which requires it."]}),"\n",(0,o.jsxs)(n.li,{children:["Consume context directly in the struct component. See ",(0,o.jsx)(n.a,{href:"https://github.com/yewstack/yew/tree/master/examples/contexts/src/struct_component_subscriber.rs",children:"example of struct component as a consumer"})]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"use-cases",children:"Use cases"}),"\n",(0,o.jsx)(n.p,{children:"Generally, if some data is needed by distant components in different parts of the tree, context will likely help you.\r\nHere are some examples of such cases:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Theming"}),": You can put a context at the top of the app that holds your app theme and use it to adjust the visual appearance, as shown in the above example."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Current user account"}),": In many cases, components need to know the currently logged-in user. You can use a context to provide the current user object to the components."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"considerations-to-make-before-using-contexts",children:"Considerations to make before using contexts"}),"\n",(0,o.jsx)(n.p,{children:"Contexts are very easy to use. That makes them very easy to misuse/overuse.\r\nJust because you can use a context to share props to components multiple levels deep, does not mean that you should."}),"\n",(0,o.jsxs)(n.p,{children:["For example, you may be able to extract a component and pass that component as a child to another component. For example,\r\nyou may have a ",(0,o.jsx)(n.code,{children:"Layout"})," component that takes ",(0,o.jsx)(n.code,{children:"articles"})," as a prop and passes it down to ",(0,o.jsx)(n.code,{children:"ArticleList"})," component.\r\nYou should refactor the ",(0,o.jsx)(n.code,{children:"Layout"})," component to take children as props and display ",(0,o.jsx)(n.code,{children:"<Layout> <ArticleList {articles} /> </Layout>"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"mutating-the-context-value-of-a-child",children:"Mutating the context value of a child"}),"\n",(0,o.jsxs)(n.p,{children:["Because of Rust's ownership rules, a context cannot have a method that takes ",(0,o.jsx)(n.code,{children:"&mut self"})," that can be called by children.\r\nTo mutate a context's value, we must combine it with a reducer. This is done by using the\r\n",(0,o.jsx)(n.a,{href:"https://yew-rs-api.web.app/next/yew/functional/fn.use_reducer.html",children:(0,o.jsx)(n.code,{children:"use_reducer"})})," hook."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"https://github.com/yewstack/yew/tree/master/examples/contexts",children:"contexts example"})," demonstrates mutable contexts\r\nwith the help of contexts"]}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.a,{href:"https://github.com/yewstack/yew/tree/master/examples/contexts",children:"contexts example"})]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var o=t(6540);const r={},s=o.createContext(r);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);