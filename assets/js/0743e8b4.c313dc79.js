"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[794],{8350:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var t=n(4848),r=n(8453);const i={title:"Properties",description:"Parent to child communication"},s=void 0,a={id:"concepts/components/properties",title:"Properties",description:"Parent to child communication",source:"@site/versioned_docs/version-0.18.0/concepts/components/properties.mdx",sourceDirName:"concepts/components",slug:"/concepts/components/properties",permalink:"/demo/docs/0.18.0/concepts/components/properties",draft:!1,unlisted:!1,editUrl:"https://google.com/versioned_docs/version-0.18.0/concepts/components/properties.mdx",tags:[],version:"0.18.0",frontMatter:{title:"Properties",description:"Parent to child communication"},sidebar:"docs",previous:{title:"Callbacks",permalink:"/demo/docs/0.18.0/concepts/components/callbacks"},next:{title:"Children",permalink:"/demo/docs/0.18.0/concepts/components/children"}},c={},l=[{value:"Derive macro",id:"derive-macro",level:2},{value:"Field attributes",id:"field-attributes",level:3},{value:"<code>#[prop_or_default]</code>",id:"prop_or_default",level:4},{value:"<code>#[prop_or(value)]</code>",id:"prop_orvalue",level:4},{value:"<code>#[prop_or_else(function)]</code>",id:"prop_or_elsefunction",level:4},{value:"PartialEq",id:"partialeq",level:2},{value:"Memory/speed overhead of using Properties",id:"memoryspeed-overhead-of-using-properties",level:2},{value:"Example",id:"example",level:2},{value:"Props macro",id:"props-macro",level:2}];function d(e){const o={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(o.p,{children:["Properties enable child and parent components to communicate with each other.\r\nEvery component has an associated properties type which describes what is passed down from the parent.\r\nIn theory this can be any type that implements the ",(0,t.jsx)(o.code,{children:"Properties"})," trait, but in practice there's no\r\nreason for it to be anything but a struct where each field represents a property."]}),"\n",(0,t.jsx)(o.h2,{id:"derive-macro",children:"Derive macro"}),"\n",(0,t.jsxs)(o.p,{children:["Instead of implementing the ",(0,t.jsx)(o.code,{children:"Properties"})," trait yourself, you should use ",(0,t.jsx)(o.code,{children:"#[derive(Properties)]"})," to\r\nautomatically generate the implementation instead.\r\nTypes for which you derive ",(0,t.jsx)(o.code,{children:"Properties"})," must also implement ",(0,t.jsx)(o.code,{children:"Clone"}),"."]}),"\n",(0,t.jsx)(o.h3,{id:"field-attributes",children:"Field attributes"}),"\n",(0,t.jsxs)(o.p,{children:["When deriving ",(0,t.jsx)(o.code,{children:"Properties"}),", all fields are required by default.\r\nThe following attributes allow you to give your props initial values which will be used unless they're set to another value."]}),"\n",(0,t.jsx)(o.admonition,{type:"tip",children:(0,t.jsx)(o.p,{children:"Attributes aren't visible in Rustdoc generated documentation.\r\nThe docstrings of your properties should mention whether a prop is optional and if it has a special default value."})}),"\n",(0,t.jsx)(o.h4,{id:"prop_or_default",children:(0,t.jsx)(o.code,{children:"#[prop_or_default]"})}),"\n",(0,t.jsxs)(o.p,{children:["Initialize the prop value with the default value of the field's type using the ",(0,t.jsx)(o.code,{children:"Default"})," trait."]}),"\n",(0,t.jsx)(o.h4,{id:"prop_orvalue",children:(0,t.jsx)(o.code,{children:"#[prop_or(value)]"})}),"\n",(0,t.jsxs)(o.p,{children:["Use ",(0,t.jsx)(o.code,{children:"value"})," to initialize the prop value. ",(0,t.jsx)(o.code,{children:"value"})," can be any expression that returns the field's type.\r\nFor example, to default a boolean prop to ",(0,t.jsx)(o.code,{children:"true"}),", use the attribute ",(0,t.jsx)(o.code,{children:"#[prop_or(true)]"}),"."]}),"\n",(0,t.jsx)(o.h4,{id:"prop_or_elsefunction",children:(0,t.jsx)(o.code,{children:"#[prop_or_else(function)]"})}),"\n",(0,t.jsxs)(o.p,{children:["Call ",(0,t.jsx)(o.code,{children:"function"})," to initialize the prop value. ",(0,t.jsx)(o.code,{children:"function"})," should have the signature ",(0,t.jsx)(o.code,{children:"FnMut() -> T"})," where ",(0,t.jsx)(o.code,{children:"T"})," is the field type."]}),"\n",(0,t.jsx)(o.h2,{id:"partialeq",children:"PartialEq"}),"\n",(0,t.jsxs)(o.p,{children:["It makes sense to derive ",(0,t.jsx)(o.code,{children:"PartialEq"})," on your props if you can do so.\r\nUsing ",(0,t.jsx)(o.code,{children:"PartialEq"})," makes it much easier to avoid unnecessary rendering (this is explained in the ",(0,t.jsx)(o.strong,{children:"Optimizations & Best Practices"})," section)."]}),"\n",(0,t.jsx)(o.h2,{id:"memoryspeed-overhead-of-using-properties",children:"Memory/speed overhead of using Properties"}),"\n",(0,t.jsxs)(o.p,{children:["In ",(0,t.jsx)(o.code,{children:"Component::view"}),", you take a reference to the component's state, and use that to create ",(0,t.jsx)(o.code,{children:"Html"}),". Properties, however, are owned values. This means that in order to create them and pass them to child components, we need to take ownership of the references provided in the ",(0,t.jsx)(o.code,{children:"view"})," function. This is done by implicitly cloning the references as they are passed to components in order to get owned values."]}),"\n",(0,t.jsx)(o.p,{children:"This means that each component has its own distinct copy of the state passed down from its parent, and that whenever you re-render a component, the props for all child components of the re-rendering component will have to be cloned."}),"\n",(0,t.jsxs)(o.p,{children:["The implication of this is if you would otherwise be passing ",(0,t.jsx)(o.em,{children:"huge"})," amounts of data down as props (Strings that are 10s of kilobytes in size), you may want to consider turning your child component into a function which returns ",(0,t.jsx)(o.code,{children:"Html"})," that the parent calls, as this means that data does not have to be cloned."]}),"\n",(0,t.jsxs)(o.p,{children:["If you won't need to modify the data passed down through props you can wrap it in an ",(0,t.jsx)(o.code,{children:"Rc"})," so that only a reference-counted pointer to the data is cloned, instead of the actual data itself."]}),"\n",(0,t.jsx)(o.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-rust",children:"use std::rc::Rc;\r\nuse yew::Properties;\r\n\r\n#[derive(Clone, PartialEq)]\r\npub enum LinkColor {\r\n    Blue,\r\n    Red,\r\n    Green,\r\n    Black,\r\n    Purple,\r\n}\r\n\r\nfn create_default_link_color() -> LinkColor {\r\n    LinkColor::Blue\r\n}\r\n\r\n#[derive(Properties, Clone, PartialEq)]\r\npub struct LinkProps {\r\n    /// The link must have a target.\r\n    href: String,\r\n    /// If the link text is huge, this will make copying the string much cheaper.\r\n    /// This isn't usually recommended unless performance is known to be a problem.\r\n    text: Rc<str>,\r\n    /// Color of the link. Defaults to `Blue`.\r\n    #[prop_or_else(create_default_link_color)]\r\n    color: LinkColor,\r\n    /// The view function will not specify a size if this is None.\r\n    #[prop_or_default]\r\n    size: Option<u32>,\r\n    /// When the view function doesn't specify active, it defaults to true.\r\n    #[prop_or(true)]\r\n    active: bool,\r\n}\n"})}),"\n",(0,t.jsx)(o.h2,{id:"props-macro",children:"Props macro"}),"\n",(0,t.jsxs)(o.p,{children:["The ",(0,t.jsx)(o.code,{children:"yew::props!"})," macro allows you to build properties the same way the ",(0,t.jsx)(o.code,{children:"html!"})," macro does it."]}),"\n",(0,t.jsxs)(o.p,{children:["The macro uses the same syntax as a struct expression except that you can't use attributes or a base expression (",(0,t.jsx)(o.code,{children:"Foo { ..base }"}),").\r\nThe type path can either point to the props directly (",(0,t.jsx)(o.code,{children:"path::to::Props"}),") or the associated properties of a component (",(0,t.jsx)(o.code,{children:"MyComp::Properties"}),")."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-rust",children:'use std::rc::Rc;\r\nuse yew::props;\r\n\r\nlet props = yew::props!(LinkProps {\r\n    href: "/",\r\n    text: Rc::from("imagine this text being really long"),\r\n    size: 64,\r\n});\r\n\r\n// build the associated properties of a component\r\nlet props = yew::props!(Model::Properties {\r\n    href: "/book",\r\n    text: Rc::from("my bestselling novel"),\r\n});\n'})})]})}function p(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>s,x:()=>a});var t=n(6540);const r={},i=t.createContext(r);function s(e){const o=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);