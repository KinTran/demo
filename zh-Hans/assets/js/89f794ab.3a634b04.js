"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[1165],{9001:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=t(4848),o=t(8453);const s={title:"Pre-defined Hooks",description:"The pre-defined Hooks that Yew comes with "},c=void 0,i={id:"concepts/function-components/pre-defined-hooks",title:"Pre-defined Hooks",description:"The pre-defined Hooks that Yew comes with ",source:"@site/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx",sourceDirName:"concepts/function-components",slug:"/concepts/function-components/pre-defined-hooks",permalink:"/demo/zh-Hans/docs/0.19.0/concepts/function-components/pre-defined-hooks",draft:!1,unlisted:!1,editUrl:"https://google.com/versioned_docs/version-0.19.0/concepts/function-components/pre-defined-hooks.mdx",tags:[],version:"0.19.0",frontMatter:{title:"Pre-defined Hooks",description:"The pre-defined Hooks that Yew comes with "},sidebar:"docs",previous:{title:"#[function_component]",permalink:"/demo/zh-Hans/docs/0.19.0/concepts/function-components/attribute"},next:{title:"Custom Hooks",permalink:"/demo/zh-Hans/docs/0.19.0/concepts/function-components/custom-hooks"}},d={},l=[{value:"<code>use_state</code>",id:"use_state",level:2},{value:"Example",id:"example",level:3},{value:"<code>use_state_eq</code>",id:"use_state_eq",level:2},{value:"<code>use_ref</code>",id:"use_ref",level:2},{value:"<code>use_mut_ref</code>",id:"use_mut_ref",level:2},{value:"Example",id:"example-1",level:3},{value:"<code>use_node_ref</code>",id:"use_node_ref",level:2},{value:"Example",id:"example-2",level:3},{value:"<code>use_reducer</code>",id:"use_reducer",level:2},{value:"Example",id:"example-3",level:3},{value:"<code>use_reducer_eq</code>",id:"use_reducer_eq",level:2},{value:"<code>use_effect</code>",id:"use_effect",level:2},{value:"Example",id:"example-4",level:3},{value:"<code>use_effect_with_deps</code>",id:"use_effect_with_deps",level:3},{value:"<code>use_context</code>",id:"use_context",level:2},{value:"Example",id:"example-5",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"use_state",children:(0,r.jsx)(n.code,{children:"use_state"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_state"})," is used to manage state in a function component.\r\nIt returns a ",(0,r.jsx)(n.code,{children:"UseStateHandle"})," object which ",(0,r.jsx)(n.code,{children:"Deref"}),"s to the current value\r\nand provides a ",(0,r.jsx)(n.code,{children:"set"})," method to update the value."]}),"\n",(0,r.jsx)(n.p,{children:"The hook takes a function as input which determines the initial state.\r\nThis value remains up-to-date on subsequent renders."}),"\n",(0,r.jsxs)(n.p,{children:["The setter function is guaranteed to be the same across the entire\r\ncomponent lifecycle. You can safely omit the ",(0,r.jsx)(n.code,{children:"UseStateHandle"})," from the\r\ndependents of ",(0,r.jsx)(n.code,{children:"use_effect_with_deps"})," if you only intend to set\r\nvalues from within the hook."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook will always trigger a re-render upon receiving a new state. See\r\n",(0,r.jsx)(n.a,{href:"#use_state_eq",children:(0,r.jsx)(n.code,{children:"use_state_eq"})})," if you want the component to only\r\nre-render when the state changes."]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use yew::{Callback, function_component, html, use_state};\r\n\r\n#[function_component(UseState)]\r\nfn state() -> Html {\r\n    let counter = use_state(|| 0);\r\n    let onclick = {\r\n        let counter = counter.clone();\r\n        Callback::from(move |_| counter.set(*counter + 1))\r\n    };\r\n\r\n\r\n    html! {\r\n        <div>\r\n            <button {onclick}>{ "Increment value" }</button>\r\n            <p>\r\n                <b>{ "Current value: " }</b>\r\n                { *counter }\r\n            </p>\r\n        </div>\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsxs)(n.p,{children:["The value held in the handle will reflect the value at the time the\r\nhandle is returned by the ",(0,r.jsx)(n.code,{children:"use_state"}),". It is possible that the handle\r\ndoes not dereference to an up to date value if you are moving it into a\r\n",(0,r.jsx)(n.code,{children:"use_effect_with_deps"})," hook. You can register the\r\nstate to the dependents so the hook can be updated when the value changes."]})}),"\n",(0,r.jsx)(n.h2,{id:"use_state_eq",children:(0,r.jsx)(n.code,{children:"use_state_eq"})}),"\n",(0,r.jsxs)(n.p,{children:["This hook has the same effect as ",(0,r.jsx)(n.code,{children:"use_state"})," but will only trigger a\r\nre-render when the setter receives a value that ",(0,r.jsx)(n.code,{children:"prev_state != next_state"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook requires the state object to implement ",(0,r.jsx)(n.code,{children:"PartialEq"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"use_ref",children:(0,r.jsx)(n.code,{children:"use_ref"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_ref"})," is used for obtaining an immutable reference to a value.\r\nIts state persists across renders."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_ref"})," can be useful for keeping things in scope for the lifetime of the component, so long as\r\nyou don't store a clone of the resulting ",(0,r.jsx)(n.code,{children:"Rc"})," anywhere that outlives the component."]}),"\n",(0,r.jsxs)(n.p,{children:["If you need a mutable reference, consider using ",(0,r.jsx)(n.a,{href:"#use_mut_ref",children:(0,r.jsx)(n.code,{children:"use_mut_ref"})}),".\r\nIf you need the component to be re-rendered on state change, consider using ",(0,r.jsx)(n.a,{href:"#use_state",children:(0,r.jsx)(n.code,{children:"use_state"})}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// EventBus is an implementation of yew_agent::Agent\r\nuse website_test::agents::EventBus;\r\nuse yew::{function_component, html, use_ref, use_state, Callback};\r\nuse yew_agent::Bridged;\r\n\r\n#[function_component(UseRef)]\r\nfn ref_hook() -> Html {\r\n    let greeting = use_state(|| "No one has greeted me yet!".to_owned());\r\n\r\n    {\r\n        let greeting = greeting.clone();\r\n        use_ref(|| EventBus::bridge(Callback::from(move |msg| {\r\n            greeting.set(msg);\r\n        })));\r\n    }\r\n\r\n    html! {\r\n        <div>\r\n            <span>{ (*greeting).clone() }</span>\r\n        </div>\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"use_mut_ref",children:(0,r.jsx)(n.code,{children:"use_mut_ref"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_mut_ref"})," is used for obtaining a mutable reference to a value.\r\nIts state persists across renders."]}),"\n",(0,r.jsxs)(n.p,{children:["It is important to note that you do not get notified of state changes.\r\nIf you need the component to be re-rendered on state change, consider using ",(0,r.jsx)(n.a,{href:"#use_state",children:(0,r.jsx)(n.code,{children:"use_state"})}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use web_sys::HtmlInputElement;\r\nuse yew::{\r\n    events::Event,\r\n    function_component, html, use_mut_ref, use_state,\r\n    Callback, TargetCast,\r\n};\r\n\r\n#[function_component(UseMutRef)]\r\nfn mut_ref_hook() -> Html {\r\n    let message = use_state(|| "".to_string());\r\n    let message_count = use_mut_ref(|| 0);\r\n\r\n    let onclick = Callback::from(move |_| {\r\n        let window = gloo_utils::window();\r\n\r\n        if *message_count.borrow_mut() > 3 {\r\n            window.alert_with_message("Message limit reached").unwrap();\r\n        } else {\r\n            *message_count.borrow_mut() += 1;\r\n            window.alert_with_message("Message sent").unwrap();\r\n        }\r\n    });\r\n\r\n    let onchange = {\r\n        let message = message.clone();\r\n        Callback::from(move |e: Event| {\r\n            let input: HtmlInputElement = e.target_unchecked_into();\r\n            message.set(input.value());\r\n        })\r\n    };\r\n\r\n    html! {\r\n        <div>\r\n            <input {onchange} value={(*message).clone()} />\r\n            <button {onclick}>{ "Send" }</button>\r\n        </div>\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"use_node_ref",children:(0,r.jsx)(n.code,{children:"use_node_ref"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_node_ref"})," is used for obtaining a ",(0,r.jsx)(n.code,{children:"NodeRef"})," that persists across renders."]}),"\n",(0,r.jsxs)(n.p,{children:["When conditionally rendering elements you can use ",(0,r.jsx)(n.code,{children:"NodeRef"})," in conjunction with ",(0,r.jsx)(n.code,{children:"use_effect_with_deps"}),"\r\nto perform actions each time an element is rendered and just before its going to be removed from the\r\nDOM."]}),"\n",(0,r.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use web_sys::HtmlInputElement;\r\nuse yew::{\r\n    function_component, functional::*, html,\r\n    NodeRef\r\n};\r\n\r\n#[function_component(UseRef)]\r\npub fn ref_hook() -> Html {\r\n    let input_ref = use_node_ref();\r\n    let value = use_state(|| 25f64);\r\n\r\n    let onclick = {\r\n        let input_ref = input_ref.clone();\r\n        let value = value.clone();\r\n        move |_| {\r\n            if let Some(input) = input_ref.cast::<HtmlInputElement>() {\r\n                value.set(*value + input.value_as_number());\r\n            }\r\n        }\r\n    };\r\n\r\n    html! {\r\n        <div>\r\n            <input ref={input_ref} type="number" />\r\n            <button {onclick}>{ format!("Add input to {}", *value) }</button>\r\n        </div>\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"use_reducer",children:(0,r.jsx)(n.code,{children:"use_reducer"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_reducer"})," is an alternative to ",(0,r.jsx)(n.a,{href:"#use_state",children:(0,r.jsx)(n.code,{children:"use_state"})}),". It is used to handle component's state and is used\r\nwhen complex actions needs to be performed on said state."]}),"\n",(0,r.jsxs)(n.p,{children:["It accepts an initial state function and returns a ",(0,r.jsx)(n.code,{children:"UseReducerHandle"})," that dereferences to the state,\r\nand a dispatch function.\r\nThe dispatch function takes one argument of type ",(0,r.jsx)(n.code,{children:"Action"}),". When called, the action and current value\r\nare passed to the reducer function which computes a new state which is returned,\r\nand the component is re-rendered."]}),"\n",(0,r.jsxs)(n.p,{children:["The dispatch function is guaranteed to be the same across the entire\r\ncomponent lifecycle. You can safely omit the ",(0,r.jsx)(n.code,{children:"UseReducerHandle"})," from the\r\ndependents of ",(0,r.jsx)(n.code,{children:"use_effect_with_deps"})," if you only intend to dispatch\r\nvalues from within the hooks."]}),"\n",(0,r.jsxs)(n.p,{children:["The state object returned by the initial state function is required to\r\nimplement a ",(0,r.jsx)(n.code,{children:"Reducible"})," trait which provides an ",(0,r.jsx)(n.code,{children:"Action"})," type and a\r\nreducer function."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook will always trigger a re-render upon receiving an action. See\r\n",(0,r.jsx)(n.a,{href:"#use_reducer_eq",children:(0,r.jsx)(n.code,{children:"use_reducer_eq"})})," if you want the component to only\r\nre-render when the state changes."]}),"\n",(0,r.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use yew::prelude::*;\r\nuse std::rc::Rc;\r\n\r\n/// reducer\'s Action\r\nenum CounterAction {\r\n    Double,\r\n    Square,\r\n}\r\n\r\n/// reducer\'s State\r\nstruct CounterState {\r\n    counter: i32,\r\n}\r\n\r\nimpl Default for CounterState {\r\n    fn default() -> Self {\r\n        Self { counter: 1 }\r\n    }\r\n}\r\n\r\nimpl Reducible for CounterState {\r\n    /// Reducer Action Type\r\n    type Action = CounterAction;\r\n\r\n    /// Reducer Function\r\n    fn reduce(self: Rc<Self>, action: Self::Action) -> Rc<Self> {\r\n        let next_ctr = match action {\r\n            CounterAction::Double => self.counter * 2,\r\n            CounterAction::Square => self.counter.pow(2)\r\n        };\r\n\r\n        Self { counter: next_ctr }.into()\r\n    }\r\n}\r\n\r\n#[function_component(UseReducer)]\r\nfn reducer() -> Html {\r\n    // The use_reducer hook takes an initialization function which will be called only once.\r\n    let counter = use_reducer(CounterState::default);\r\n\r\n   let double_onclick = {\r\n        let counter = counter.clone();\r\n        Callback::from(move |_| counter.dispatch(CounterAction::Double))\r\n    };\r\n    let square_onclick = {\r\n        let counter = counter.clone();\r\n        Callback::from(move |_| counter.dispatch(CounterAction::Square))\r\n    };\r\n\r\n    html! {\r\n        <>\r\n            <div id="result">{ counter.counter }</div>\r\n\r\n            <button onclick={double_onclick}>{ "Double" }</button>\r\n            <button onclick={square_onclick}>{ "Square" }</button>\r\n        </>\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsxs)(n.p,{children:["The value held in the handle will reflect the value of at the time the\r\nhandle is returned by the ",(0,r.jsx)(n.code,{children:"use_reducer"}),". It is possible that the handle does\r\nnot dereference to an up to date value if you are moving it into a\r\n",(0,r.jsx)(n.code,{children:"use_effect_with_deps"})," hook. You can register the\r\nstate to the dependents so the hook can be updated when the value changes."]})}),"\n",(0,r.jsx)(n.h2,{id:"use_reducer_eq",children:(0,r.jsx)(n.code,{children:"use_reducer_eq"})}),"\n",(0,r.jsxs)(n.p,{children:["This hook has the same effect as ",(0,r.jsx)(n.code,{children:"use_reducer"})," but will only trigger a\r\nre-render when the reducer function produces a value that ",(0,r.jsx)(n.code,{children:"prev_state != next_state"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook requires the state object to implement ",(0,r.jsx)(n.code,{children:"PartialEq"})," in addition\r\nto the ",(0,r.jsx)(n.code,{children:"Reducible"})," trait required by ",(0,r.jsx)(n.code,{children:"use_reducer"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"use_effect",children:(0,r.jsx)(n.code,{children:"use_effect"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_effect"})," is used for hooking into the component's lifecycle.\r\nSimilar to ",(0,r.jsx)(n.code,{children:"rendered"})," from the ",(0,r.jsx)(n.code,{children:"Component"})," trait,\r\n",(0,r.jsx)(n.code,{children:"use_effect"})," takes a function which is called after the render finishes."]}),"\n",(0,r.jsx)(n.p,{children:"The input function has to return a closure, the destructor, which is called when the component is destroyed.\r\nThe destructor can be used to clean up the effects introduced and it can take ownership of values to delay dropping them until the component is destroyed."}),"\n",(0,r.jsx)(n.h3,{id:"example-4",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use yew::{Callback, function_component, html, use_effect, use_state};\r\n\r\n#[function_component(UseEffect)]\r\nfn effect() -> Html {\r\n    let counter = use_state(|| 0);\r\n\r\n    {\r\n        let counter = counter.clone();\r\n        use_effect(move || {\r\n            // Make a call to DOM API after component is rendered\r\n            gloo_utils::document().set_title(&format!("You clicked {} times", *counter));\r\n\r\n            // Perform the cleanup\r\n            || gloo_utils::document().set_title("You clicked 0 times")\r\n        });\r\n    }\r\n    let onclick = {\r\n        let counter = counter.clone();\r\n        Callback::from(move |_| counter.set(*counter + 1))\r\n    };\r\n\r\n    html! {\r\n        <button {onclick}>{ format!("Increment to {}", *counter) }</button>\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"use_effect_with_deps",children:(0,r.jsx)(n.code,{children:"use_effect_with_deps"})}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes, it's needed to manually define dependencies for ",(0,r.jsx)(n.a,{href:"#use_effect",children:(0,r.jsx)(n.code,{children:"use_effect"})}),". In such cases, we use ",(0,r.jsx)(n.code,{children:"use_effect_with_deps"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:",no_run",children:"use yew::use_effect_with_deps;\r\n\r\nuse_effect_with_deps(\r\n    move |_| {\r\n        // ...\r\n        || ()\r\n    },\r\n    (), // dependents\r\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": ",(0,r.jsx)(n.code,{children:"dependents"})," must implement ",(0,r.jsx)(n.code,{children:"PartialEq"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"use_context",children:(0,r.jsx)(n.code,{children:"use_context"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use_context"})," is used for consuming ",(0,r.jsx)(n.a,{href:"/demo/zh-Hans/docs/0.19.0/concepts/contexts",children:"contexts"})," in function components."]}),"\n",(0,r.jsx)(n.h3,{id:"example-5",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use yew::{ContextProvider, function_component, html, use_context, use_state};\r\n\r\n\r\n/// App theme\r\n#[derive(Clone, Debug, PartialEq)]\r\nstruct Theme {\r\n    foreground: String,\r\n    background: String,\r\n}\r\n\r\n/// Main component\r\n#[function_component(App)]\r\npub fn app() -> Html {\r\n    let ctx = use_state(|| Theme {\r\n        foreground: "#000000".to_owned(),\r\n        background: "#eeeeee".to_owned(),\r\n    });\r\n\r\n    html! {\r\n        // `ctx` is type `Rc<UseStateHandle<Theme>>` while we need `Theme`\r\n        // so we deref it.\r\n        // It derefs to `&Theme`, hence the clone\r\n        <ContextProvider<Theme> context={(*ctx).clone()}>\r\n            // Every child here and their children will have access to this context.\r\n            <Toolbar />\r\n        </ContextProvider<Theme>>\r\n    }\r\n}\r\n\r\n/// The toolbar.\r\n/// This component has access to the context\r\n#[function_component(Toolbar)]\r\npub fn toolbar() -> Html {\r\n    html! {\r\n        <div>\r\n            <ThemedButton />\r\n        </div>\r\n    }\r\n}\r\n\r\n/// Button placed in `Toolbar`.\r\n/// As this component is a child of `ThemeContextProvider` in the component tree, it also has access to the context.\r\n#[function_component(ThemedButton)]\r\npub fn themed_button() -> Html {\r\n    let theme = use_context::<Theme>().expect("no ctx found");\r\n\r\n    html! {\r\n        <button style={format!("background: {}; color: {};", theme.background, theme.foreground)}>\r\n            { "Click me!" }\r\n        </button>\r\n    }\r\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var r=t(6540);const o={},s=r.createContext(o);function c(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);