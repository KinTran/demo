"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[3840],{8831:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>h});var s=t(4848),o=t(8453),i=t(6025),r=t(1122);const a={title:"Agents",description:"Yew's Actor System"},c=void 0,d={id:"concepts/agents",title:"Agents",description:"Yew's Actor System",source:"@site/versioned_docs/version-0.19.0/concepts/agents.mdx",sourceDirName:"concepts",slug:"/concepts/agents",permalink:"/demo/zh-Hans/docs/0.19.0/concepts/agents",draft:!1,unlisted:!1,editUrl:"https://google.com/versioned_docs/version-0.19.0/concepts/agents.mdx",tags:[],version:"0.19.0",frontMatter:{title:"Agents",description:"Yew's Actor System"},sidebar:"docs",previous:{title:"Custom Hooks",permalink:"/demo/zh-Hans/docs/0.19.0/concepts/function-components/custom-hooks"},next:{title:"Contexts",permalink:"/demo/zh-Hans/docs/0.19.0/concepts/contexts"}},l={},h=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"Types of Agents",id:"types-of-agents",level:2},{value:"Reaches",id:"reaches",level:3},{value:"Communication between Agents and Components",id:"communication-between-agents-and-components",level:2},{value:"Bridges",id:"bridges",level:3},{value:"Dispatchers",id:"dispatchers",level:3},{value:"Overhead",id:"overhead",level:2},{value:"Further reading",id:"further-reading",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Agents are similar to Angular's ",(0,s.jsx)(n.a,{href:"https://angular.io/guide/architecture-services",children:"Services"}),"\r\n(but without dependency injection), and provide Yew with an\r\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Actor_model",children:"Actor Model"}),". Agents can be used to route messages\r\nbetween components independently of where they sit in the component hierarchy, or they can be used\r\nto create shared state between different components. Agents can also be used to offload\r\ncomputationally expensive tasks from the main thread which renders the UI. There is also planned\r\nsupport for using agents to allow Yew applications to communicate across tabs (in the future)."]}),"\n",(0,s.jsxs)(n.p,{children:["In order for agents to run concurrently, Yew uses\r\n",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"web-workers"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,s.jsx)(r.A,{alt:"agent lifecycle diagram",sources:{light:(0,i.Ay)("/img/agent-lifecycle-light.svg"),dark:(0,i.Ay)("/img/agent-lifecycle-dark.svg")}}),"\n",(0,s.jsx)(n.h2,{id:"types-of-agents",children:"Types of Agents"}),"\n",(0,s.jsx)(n.h3,{id:"reaches",children:"Reaches"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Context - There will exist at most one instance of a Context Agent at any given time. Bridges will\r\nspawn or connect to an already spawned agent on the UI thread. This can be used to coordinate\r\nstate between components or other agents. When no bridges are connected to this agent, the agent\r\nwill disappear."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Job - Spawn a new agent on the UI thread for every new bridge. This is good for moving shared but\r\nindependent behavior that communicates with the browser out of components. (TODO verify) When\r\nthe task is done, the agent will disappear."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Public - Same as Context, but runs on its own web worker."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Private - Same as Job, but runs on its own web worker."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Global (WIP)"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"communication-between-agents-and-components",children:"Communication between Agents and Components"}),"\n",(0,s.jsx)(n.h3,{id:"bridges",children:"Bridges"}),"\n",(0,s.jsx)(n.p,{children:"A bridge allows bi-directional communication between an agent and a component. Bridges also allow agents to communicate with one another."}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"use_bridge"})," hook is also provided to create bridges in a function component."]}),"\n",(0,s.jsx)(n.h3,{id:"dispatchers",children:"Dispatchers"}),"\n",(0,s.jsx)(n.p,{children:"A dispatcher allows uni-directional communication between a component and an agent. A dispatcher allows a component to send messages to an agent."}),"\n",(0,s.jsx)(n.h2,{id:"overhead",children:"Overhead"}),"\n",(0,s.jsxs)(n.p,{children:["Agents that use web workers (i.e. Private and Public) will incur a serialization overhead on the\r\nmessages they send and receive. They use ",(0,s.jsx)(n.a,{href:"https://github.com/servo/bincode",children:"bincode"})," to communicate\r\nwith other threads, so the cost is substantially higher than just calling a function. Unless the\r\ncost of computation will outweigh the cost of message passing, you should use agents running on the\r\nUI thread (i.e. Job or Context)."]}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/yewstack/yew/tree/yew-v0.19.3/examples/pub_sub",children:"pub_sub"})," example shows how\r\ncomponents can use agents to communicate with each other."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);